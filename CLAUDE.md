# 旧暦カレンダーアプリの開発ガイド

## 画面遷移とデータ同期（2025年5月9日更新）

### 画面間の状態同期の実装

画面間で確実にデータを同期するため、以下の実装を行いました：

1. **ScheduleViewController → ViewController への同期**
   - `viewWillDisappear`メソッドで「戻る」ボタン検出: `isMovingFromParentViewController || isBeingDismissed`
   - カレンダーマネージャー(シングルトン)に現在の日付とモードを確実に保存
   - デリゲートパターンを使用して親ビューに変更を通知
   - 実装箇所: `ScheduleViewController.swift:612-654`

2. **モード切替時のデータ同期**
   - モード変更を`UserDefaults`に保存して一貫性を確保
   - 各画面のUI更新メソッドで確実に状態を反映
   - 実装箇所: `ScheduleViewController.swift:493-516`

3. **ViewController での状態更新**
   - `viewWillAppear`で画面を完全再描画
   - カレンダーとUI要素を最新の状態で更新
   - 実装箇所: `ViewController.swift:114-149`

### UI要素のNilチェック

潜在的なクラッシュを防止するため、以下のnilチェックを追加：

1. **オプショナルチェーニング**
   - UI要素へのアクセス時に`?`を使用: `dateLabel?.textColor = designer.navigationTintColor`
   - 実装箇所: `ScheduleViewController.swift:263-268`, `ViewController.swift:570-584`

2. **明示的なnilチェック**
   - 重要なUI要素は`if let`で安全に処理: 
   ```swift
   if let toolbar = self.toolBar {
       toolbar.barTintColor = designer.navigationBarTintColor
       toolbar.tintColor = designer.navigationTintColor
   }
   ```
   - 実装箇所: `ScheduleViewController.swift:274-277`, `ViewController.swift:587-590`

### デザイン更新のためのUI設定

モード切替時に全UI要素の色を一貫して更新するため、以下を実装：

1. **backgroundColor設定**
   - 背景色を現在のモードに合わせて設定: `self.view.backgroundColor = designer.backgroundColor`

2. **テキスト色の設定**
   - すべてのラベルとテキストビューの色を更新: `moonName?.textColor = designer.navigationTintColor`

3. **ナビゲーションバーの更新**
   - タイトル、背景、テキスト色を完全に更新
   - 実装箇所: `ViewController.swift:577-580`

4. **ツールバーの更新**
   - ツールバーの色とアイコン色を更新
   - 実装箇所: `ViewController.swift:587-590`, `ScheduleViewController.swift:274-277`

## 月齢計算と月相表示

### 月齢計算の方法

アプリでは以下の月齢計算方法を実装しています：

1. **伝統的な旧暦日ベースの計算**（推奨・採用済み）
   - 計算式: `月齢 = 旧暦日 - 1`
   - 旧暦1日が新月(月齢0)、旧暦15日が満月(月齢14)となる伝統的な計算
   - 日本の旧暦の考え方に完全に一致
   - テスト結果に基づき、最も信頼性の高い方法として採用
   - 実装: `calcMoonAgeForLunarDay(lunarDay: Int) -> Double`

2. **簡易計算（旧来の実装）**
   - 計算式: `(Y - 2004)×10.88 + (M - 7)×0.97 + (D - 1) + 13.3`
   - 結果を30日周期内に収める
   - 旧暦日を入力すると、伝統的な月齢に近い値を返す
   - 実装: `calcMoonAgeSimple() -> Double`

3. **天文学的計算**
   - 基準日（2000年1月6日 18:14 GMT）からの経過日数
   - 月の周期（29.53059日）で割った余りが月齢
   - 天文学的な月齢を計算するが、旧暦日との対応が完全ではない
   - 実装: `calcMoonAgeAstronomical() -> Double`

4. **高精度計算**
   - NASA/JPL計算式に基づく
   - 月の楕円軌道などの補正項を含む
   - 天文学的に正確だが、旧暦モードのカレンダーとしては適していない
   - 実装: `calcMoonAgeHighPrecision() -> Double`

### 月齢計算方法の選定理由

複数の計算方法を比較検証した結果、「伝統的な旧暦日ベースの計算（旧暦日-1）」を採用しました。

主な理由：
1. **日本の旧暦との整合性**：旧暦1日=新月、旧暦15日=満月という伝統的な考え方に完全に一致
2. **テスト結果**：特定の日付（例：2025年3月17日）で検証したところ、旧暦日-1が最も適切な値を示した
3. **一貫性**：旧暦カレンダーアプリとして、月の満ち欠けと旧暦日の関係が直感的に理解できる
4. **信頼性**：特に月の後半（月齢15〜29）において、他の計算方法よりも信頼性が高い

テスト例：
```
日付          | 旧暦          | 旧暦日-1 | 天文学的 | 天文学的(小数点1位)
-------------------------------------------------------------------
2025/3/15     | 2025/2/15     |     14.0 |    14.20 |                14.2
2025/3/16     | 2025/2/16     |     15.0 |    15.21 |                15.2
2025/3/17     | 2025/2/18     |     17.0 |    16.22 |                16.2
```

重要な参照日（2025年3月17日）は、旧暦では2025年2月18日となり、旧暦日-1では月齢17.0となります。天文学的計算では16.22（小数点第1位で切り捨てると16.2）となり、誤差が大きくなります。

### 月相と画像の対応

#### 月齢と月相名

```swift
// 月齢に対応する月の満ち欠けの名称
let moonName = ["新月", "", "繊月", "三日月", "", "", "", "上弦の月", "", "", "十日夜の月",         //0〜10
               "", "", "十三夜月", "小望月", "満月", "十六夜", "立待月", "居待月", "寝待月", "更待月", //11〜20
               "", "", "下弦の月", "", "", "有明月", "", "", "", "三十日月"]  //21〜30
```

- 空文字列（""）は、その月齢に特別な名称がないことを示す
- 月齢0: 新月、月齢7: 上弦の月、月齢15: 満月、月齢23: 下弦の月が主要な月相

#### 月齢と画像ファイル

画像ファイル名と月齢の対応：
- `moon0.png` または `moon0_90x90.png` → 新月（月齢0）
- `moon7.png` または `moon7_90x90.png` → 上弦の月（月齢7）
- `moon15.png` または `moon15_90x90.png` → 満月（月齢15）
- `moon23.png` または `moon23_90x90.png` → 下弦の月（月齢23）
- `moon30.png` または `moon30_90x90.png` → 新月前夜（月齢29.5〜30）

画像番号への変換ロジック（2025年5月9日更新）：
```swift
// 伝統的計算（旧暦日-1）による月齢を使用
let calculatedMoonAge = traditionalMoonAge

// 月齢から画像番号への変換（整数部分のみ使用）
let imageNumber = Int(calculatedMoonAge)

// 範囲を0〜30に制限
let safeImageNumber = max(min(imageNumber, 30), 0)

// 画像を表示
self.moonImage.image = UIImage(named:"moon\(safeImageNumber)_90x90.png")
```

月齢と画像番号の整合性：
- 旧暦日-1を月齢として使用することで、画像番号と月齢が常に一致
- 小数点以下は切り捨て、整数値のみを画像番号として使用
- 月の満ち欠けと旧暦日の対応関係が視覚的に明確

### 画面ごとの月齢表示方法（2025年5月9日更新）

#### 一覧表示（ViewController）
- 旧暦モードでは、旧暦日（tagNumber）から直接月齢を計算: `月齢 = 旧暦日 - 1`
- 旧暦日に対応する月の画像を表示: `moon\(tagNumber).png`
- 実装箇所: `ViewController.swift:375-377`
```swift
// 伝統的計算（旧暦日-1）を使用
let traditionalMoonAge = calendarManager.calcMoonAgeForLunarDay(lunarDay: tagNumber)
let moonAge = traditionalMoonAge  // この月齢値を使用
```

#### 詳細画面（ScheduleViewController）
- 旧暦日から計算した月齢をテキストで表示（整数値のみ）
- 計算された月齢に基づいて月相名を表示（空の場合は非表示）
- 月齢に対応する月画像を表示: `moon\(imageNumber)_90x90.png`
- 実装箇所: `ScheduleViewController.swift:166-169`
```swift
// 伝統的計算（旧暦日-1）による月齢を使用
// 重要な日付でテストした結果、旧暦日-1が最も精度が高いことが判明
let calculatedMoonAge = traditionalMoonAge
```

## 開発ガイドライン

### デバッグ時の推奨事項
- 月相名と月齢の整合性を確認
- 旧暦日と月齢の関係を確認（旧暦1日 = 月齢0、旧暦15日 = 月齢14）
- 月画像が月齢に合っているか確認

### テスト（2025年5月9日更新）
旧暦カレンダーアプリの品質確保のため、以下のテストを実施し、伝統的計算（旧暦日-1）が最適であることを確認しました：

1. **旧暦日と月齢の対応テスト**
   - 旧暦1日が月齢0（新月）になることを確認
   - 旧暦15日が月齢14（満月に近い）になることを確認
   - 旧暦日が飛んでいる箇所（例：2025年3月17日は旧暦2月18日で、17日が存在しない）も正しく対応

2. **複数の月齢計算方法の比較テスト**
   - 複数の計算方法を同時に実行し、結果を比較
   - 重要な日付（2025年3月17日など）で検証した結果、伝統的計算が最も信頼性が高い
   - 特に月齢15以降で天文学的計算と最大0.8の差が生じることを確認

3. **連続する日付での月齢変化テスト**
   - 新月周辺、満月周辺、参照日周辺の7日間の変化を検証
   - 伝統的計算（旧暦日-1）が最も自然な変化を示す
   - 旧暦日の飛びに応じた月齢の変化が適切に表現される

4. **画像表示の一貫性テスト**
   - 月齢に応じた画像表示が一覧表示と詳細表示で一致
   - 伝統的計算によって画像番号と月齢の対応が明確に

### テスト結果サンプル
```
=== 参照日（3/17）周辺期間 (2025/3/15から7日間) ===

日付          | 旧暦          | 旧暦日-1 | 天文学的 | 天文学的(小数点1位) | 天文学的と旧暦日-1の差
----------------------------------------------------------------------------
2025/3/15     | 2025/2/15     |     14.0 |    14.20 |                14.2 |             0.2
2025/3/16     | 2025/2/16     |     15.0 |    15.21 |                15.2 |             0.2
2025/3/17     | 2025/2/18     |     17.0 |    16.22 |                16.2 |             0.8
2025/3/18     | 2025/2/19     |     18.0 |    17.23 |                17.2 |             0.8
2025/3/19     | 2025/2/20     |     19.0 |    18.24 |                18.2 |             0.8
2025/3/20     | 2025/2/21     |     20.0 |    19.25 |                19.2 |             0.8
2025/3/21     | 2025/2/22     |     21.0 |    20.26 |                20.2 |             0.8
```

## 復旧・バグ修正の経緯

### アプリ復旧作業（2025年5月10日）

**問題状況**:
- トップページ（カレンダー表示画面）が完全に動作しなくなる重大な問題が発生
- メイン画面での月の表示や日付表示などの基本機能が機能しない状態
- 複数の機能変更による累積的な問題で、コードが安定状態から崩れていた

**アプローチと診断**:
1. **原因調査**:
   - ViewController.swiftの問題を詳しく調査
   - CalendarManagerとの連携の問題を特定
   - 月齢計算の変更と月画像表示の方法の不一致が特に深刻な問題だった

2. **段階的な復旧計画**:
   - まず安定していた古いバージョンのコードを特定
   - 主要ファイル（ViewController.swift, CalendarManager.swift）を古いバージョンに戻す方針を決定
   - 先に行った改善（月齢計算の精度向上など）を維持しつつ、UI表示の問題を修正

3. **具体的な復旧手順**:
   - ViewController.swiftを安定版（コミット14f7233 "Optinal修正その他諸々"）に戻す
   - CalendarManager.swiftを安定版（コミットbfb9492 "月齢計算の修正と統一"）に戻す
   - メイン画面の機能を確認し、正常動作を確認
   - 復元作業のコミット履歴に残すため、それぞれ個別にコミット（333609dと6d5e55f）

**結果と評価**:
- メイン画面（トップページ）が正常に動作するようになった
- 月齢表示と月の画像表示が正しく同期するようになった
- カレンダーの日付表示と閏月の処理が正しく機能するようになった

### 閏月表示のOptional表示バグの修正（2025年5月10日）

**問題内容**:
- 旧暦の閏月が表示される際に、月の表示に「Optional(X)」という文字列が表示される問題が発生していました。
- これはScheduleViewControllerで閏月情報を表示する際に、オプショナル値が適切にアンラップされていないことが原因でした。

**修正内容**:
1. `CalendarManager.swift`の`setScheduleTitle()`メソッド内で、`ancientMonth`オプショナル値を安全にアンラップするようコードを修正しました。
   - 修正前: オプショナル値を直接文字列に変換して使用していた
   - 修正後: `guard let`を使って安全にアンラップした値を使用するよう変更

2. 修正箇所:
   ```swift
   // 修正前
   var ancientMonthStr: String = String(ancientMonth)

   if(isLeapMonth < 0) {
       ancientMonthStr = "閏\(ancientMonth)"
   }

   // 修正後
   guard let month = ancientMonth else {
       return // Return early if ancientMonth is nil
   }

   var ancientMonthStr: String = String(month)

   if(isLeapMonth < 0) {
       ancientMonthStr = "閏\(month)"
   }
   ```

3. 影響範囲:
   - この修正により、旧暦モードで閏月を表示する際に「Optional(X)」という文字列が表示されなくなりました。
   - 詳細画面（ScheduleViewController）のタイトル表示が正しく表示されるようになりました。

### モード切替時の日付変換バグの修正（2025年5月10日）

**問題内容**:
- カレンダーモード（新暦⇔旧暦）切替時に、日付が正しく対応せず、元の日付情報が失われる問題
- 特に新暦モードに戻る際に、日付が常に1日になってしまう
- モード切替時の日付の1:1対応が正しく機能していない

**解析結果**:
1. **問題の特定**:
   - `CalendarManager.swift`の`setupAnotherCalendarData()`メソッドに問題があることを特定
   - 新暦モードに戻す際、日付を強制的に1日に設定していた（`currentComps.day = 1`）
   - 旧暦から新暦への変換時に実際の日付ではなく常に29日を使用していた

2. **問題の影響**:
   - モード間の切替時に日付情報が失われる
   - 特に研究や実験目的で特定の日付の対応関係を見たい場合に支障をきたす
   - ユーザーの使い勝手が大幅に低下

**修正内容**:
1. **日付変換ロジックの改善**:
   ```swift
   // 修正前
   if(!nowLeapMonth) {  //閏月でない場合
       currentComps = converter.convertForGregorianCalendar(dateArray: [year, month, 29, 0]) as DateComponents
   } else {
       currentComps = converter.convertForGregorianCalendar(dateArray: [year, -month, 29, 0]) as DateComponents
       nowLeapMonth = false    //閏月の初期化
   }

   // 新暦変換時に曜日を設定し直す #46
   currentComps.day = 1

   // 修正後
   let currentDay = day ?? 1  // 現在の日付を使用

   if(!nowLeapMonth) {  //閏月でない場合
       currentComps = converter.convertForGregorianCalendar(dateArray: [year, month, currentDay, 0]) as DateComponents
   } else {
       currentComps = converter.convertForGregorianCalendar(dateArray: [year, -month, currentDay, -1]) as DateComponents
       nowLeapMonth = false    //閏月の初期化
   }

   // 日付が設定されていない場合のみデフォルト設定
   if currentComps.day == nil {
       currentComps.day = 1
   }
   ```

2. **修正のポイント**:
   - 実際の現在日（`day`変数）を変換に使用
   - 強制的に日付を1日にリセットしない
   - 閏月情報も正確に変換関数に引き渡す

**影響範囲と検証**:
- この修正によりモード切替時の日付対応が正確になり、ユーザー体験が向上
- ScheduleViewControllerのモード切替機能が正常に動作し、日付が失われなくなる
- 既存のワークアラウンド（`checkAndAdjustDay`メソッド）は残しつつも、ほとんど呼ばれなくなる

### 現在の状態と今後の留意点

**現在の状態**:
- アプリの主要機能（カレンダー表示、閏月表示、月齢計算、月相表示）が正常に動作
- 日付操作や画面遷移が正しく行われる
- ViewControllerとCalendarManagerが適切に連携している
- モード切替時の日付変換が正確に行われる

**今後の留意点**:
1. **オプショナル処理の徹底**:
   - Swiftのオプショナル値は常に安全に処理する（`if let`や`guard let`を使用）
   - 特に文字列表示の際は注意が必要

2. **閏月処理の検証**:
   - 閏月周辺の日付変更時には特に念入りなテストが必要
   - `nowLeapMonth`と`isLeapMonth`の2つのフラグの一貫性を常に確認
   - モード切替時の閏月の扱いには特に注意

3. **コード改善時の注意事項**:
   - 複数ファイルにまたがる変更は慎重に行い、段階的にテスト
   - バージョン管理（git）を活用して安定状態を常に記録しておく
   - 変更前後のスクリーンショットなどで視覚的に検証する
   - 「最小限の変更」原則を守り、既存コードの意図を尊重する